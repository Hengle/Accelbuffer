<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Accelbuffer</name>
    </assembly>
    <members>
        <member name="T:Accelbuffer.Compiling.Compiler">
            <summary>
            提供线程安全的编译AccelbufferScript的接口
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Compiler.HasError">
            <summary>
            获取是否出现编译错误
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Compiler.#ctor(Accelbuffer.Compiling.ErrorWriter,Accelbuffer.Compiling.KeywordManager)">
            <summary>
            初始化Compiler
            </summary>
            <param name="errorWriter"></param>
            <param name="keywordManager"></param>
        </member>
        <member name="M:Accelbuffer.Compiling.Compiler.CompileToTokens(System.String)">
            <summary>
            
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Compiling.Compiler.CompileToDeclarations(System.String)">
            <summary>
            
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Compiling.Compiler.CompileToFile(System.String,System.String,Accelbuffer.Compiling.LanguageManager)">
            <summary>
            
            </summary>
            <param name="filePath"></param>
            <param name="outputPath"></param>
            <param name="languageManager"></param>
        </member>
        <member name="M:Accelbuffer.Compiling.Compiler.CompileToTypes(System.String)">
            <summary>
            
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Compiling.Compiler.CompileToDeclarations(Accelbuffer.Compiling.Token[])">
            <summary>
            
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Compiling.Compiler.CompileToFile(System.String,Accelbuffer.Compiling.Token[],Accelbuffer.Compiling.LanguageManager)">
            <summary>
            
            </summary>
            <param name="filePath"></param>
            <param name="tokens"></param>
            <param name="languageManager"></param>
        </member>
        <member name="M:Accelbuffer.Compiling.Compiler.CompileToTypes(Accelbuffer.Compiling.Token[])">
            <summary>
            
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Compiling.Compiler.CompileToFile(System.String,Accelbuffer.Compiling.DeclarationArray,Accelbuffer.Compiling.LanguageManager)">
            <summary>
            
            </summary>
            <param name="filePath"></param>
            <param name="declarations"></param>
            <param name="languageManager"></param>
        </member>
        <member name="M:Accelbuffer.Compiling.Compiler.CompileToTypes(Accelbuffer.Compiling.DeclarationArray)">
            <summary>
            
            </summary>
            <param name="declarations"></param>
            <returns></returns>
        </member>
        <member name="T:Accelbuffer.Compiling.TypeName">
            <summary>
            类型名称
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.TypeName.RawString">
            <summary>
            类型名称的原始字符串
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.TypeName.RawStringWithoutNullableAndArraySuffix">
            <summary>
            类型名称的原始字符串没有nullable符号和数组后缀
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.TypeName.IsGenericType">
            <summary>
            获取类型是否为泛型
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.TypeName.GenericTypeDefinitionName">
            <summary>
            获取类型的泛型定义名称
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.TypeName.GenericParameters">
            <summary>
            获取类型的泛型参数
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.TypeName.IsNullable">
            <summary>
            获取类型是否是可以为空的类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.TypeName.ArraySuffixCount">
            <summary>
            获取类型的数组后缀数量
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.TypeName.ToBytes">
            <summary>
            序列化对象
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.TypeName.FromBytes(System.Byte[])">
            <summary>
            反序列化对象
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.TypeName.TypeNameSerializer">
            <summary>
            对象序列化代理（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.TypeName.TypeNameSerializer.Serialize(Accelbuffer.Compiling.TypeName,Accelbuffer.AccelWriter@)">
            <summary>
            序列化方法（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.TypeName.TypeNameSerializer.Deserialize(Accelbuffer.AccelReader@)">
            <summary>
            反序列化方法（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.TypeName.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Compiling.TypeName.op_Implicit(Accelbuffer.Compiling.TypeName)~System.String">
            <summary>
            
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:Accelbuffer.Compiling.DeclarationArray">
            <summary>
            表示一个abc文件的格式
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.DeclarationArray.Declarations">
            <summary>
            文件中包含的所有声明
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.DeclarationArray.GetBytes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Compiling.DeclarationArray.FromBytes(System.Byte[])">
            <summary>
            
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="T:Accelbuffer.Compiling.RuntimeCompiler">
            <summary>
            表示一个运行时编译器
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.RuntimeCompiler.#ctor">
            <summary>
            初始化RuntimeCompiler
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.RuntimeCompiler.Compile(Accelbuffer.Compiling.DeclarationArray)">
            <summary>
            编译一系列声明
            </summary>
            <param name="array">
            需要编译的声明列表，
            <see cref="T:Accelbuffer.Compiling.Declarations.PackageDeclaration"/>应该为首元素（如果有），
            <see cref="T:Accelbuffer.Compiling.Declarations.UsingDeclaration"/>和<see cref="T:Accelbuffer.Compiling.Declarations.UsingAsDeclaration"/>应该在所有结构声明之前
            </param>
            <returns>编译结果，Key:类型FullName，Value:类型元数据对象</returns>
        </member>
        <member name="T:Accelbuffer.Compiling.Declarations.FieldDeclaration">
            <summary>
            字段声明
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.FieldDeclaration.RealType">
            <summary>
            字段的真实类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.FieldDeclaration.Type">
            <summary>
            字段的类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.FieldDeclaration.Name">
            <summary>
            字段的名称
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.FieldDeclaration.Doc">
            <summary>
            字段的文档
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.FieldDeclaration.Index">
            <summary>
            字段的索引
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.FieldDeclaration.IsObsolete">
            <summary>
            字段是否过时
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.FieldDeclaration.IsNeverNull">
            <summary>
            字段是否永远不会为null
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.FieldDeclaration.ToBytes">
            <summary>
            序列化对象
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.FieldDeclaration.FromBytes(System.Byte[])">
            <summary>
            反序列化对象
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.Declarations.FieldDeclaration.FieldDeclarationSerializer">
            <summary>
            对象序列化代理（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.FieldDeclaration.FieldDeclarationSerializer.Serialize(Accelbuffer.Compiling.Declarations.FieldDeclaration,Accelbuffer.AccelWriter@)">
            <summary>
            序列化方法（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.FieldDeclaration.FieldDeclarationSerializer.Deserialize(Accelbuffer.AccelReader@)">
            <summary>
            反序列化方法（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.FieldDeclaration.#ctor">
            <summary>
            初始化 FieldDeclaration
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.Declarations.PackageDeclaration">
            <summary>
            包声明
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.PackageDeclaration.PackageName">
            <summary>
            包名
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.PackageDeclaration.ToBytes">
            <summary>
            序列化对象
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.PackageDeclaration.FromBytes(System.Byte[])">
            <summary>
            反序列化对象
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.Declarations.PackageDeclaration.PackageDeclarationSerializer">
            <summary>
            对象序列化代理（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.PackageDeclaration.PackageDeclarationSerializer.Serialize(Accelbuffer.Compiling.Declarations.PackageDeclaration,Accelbuffer.AccelWriter@)">
            <summary>
            序列化方法（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.PackageDeclaration.PackageDeclarationSerializer.Deserialize(Accelbuffer.AccelReader@)">
            <summary>
            反序列化方法（自动生成）
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.Declarations.StructDeclaration">
            <summary>
            结构声明
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.StructDeclaration.Visibility">
            <summary>
            可访问性
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.StructDeclaration.IsFinal">
            <summary>
            是否为密封结构
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.StructDeclaration.IsRef">
            <summary>
            是否为引用结构
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.StructDeclaration.IsNested">
            <summary>
            是否为嵌套结构
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.StructDeclaration.IsFieldIndexContinuous">
            <summary>
            所有字段的索引是否连续
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.StructDeclaration.Name">
            <summary>
            结构的名称
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.StructDeclaration.Doc">
            <summary>
            结构的文档
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.StructDeclaration.Size">
            <summary>
            结构的大小
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.StructDeclaration.Declarations">
            <summary>
            结构内的声明
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.StructDeclaration.ToBytes">
            <summary>
            序列化对象
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.StructDeclaration.FromBytes(System.Byte[])">
            <summary>
            反序列化对象
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.Declarations.StructDeclaration.StructDeclarationSerializer">
            <summary>
            对象序列化代理（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.StructDeclaration.StructDeclarationSerializer.Serialize(Accelbuffer.Compiling.Declarations.StructDeclaration,Accelbuffer.AccelWriter@)">
            <summary>
            序列化方法（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.StructDeclaration.StructDeclarationSerializer.Deserialize(Accelbuffer.AccelReader@)">
            <summary>
            反序列化方法（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.StructDeclaration.#ctor">
            <summary>
            初始化StructDeclaration
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.Declarations.UsingAsDeclaration">
            <summary>
            类型别名的声明
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.UsingAsDeclaration.TypeName">
            <summary>
            原始类型名
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.UsingAsDeclaration.AliasName">
            <summary>
            类型的别名
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.UsingAsDeclaration.ToBytes">
            <summary>
            序列化对象
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.UsingAsDeclaration.FromBytes(System.Byte[])">
            <summary>
            反序列化对象
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.Declarations.UsingAsDeclaration.UsingAsDeclarationSerializer">
            <summary>
            对象序列化代理（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.UsingAsDeclaration.UsingAsDeclarationSerializer.Serialize(Accelbuffer.Compiling.Declarations.UsingAsDeclaration,Accelbuffer.AccelWriter@)">
            <summary>
            序列化方法（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.UsingAsDeclaration.UsingAsDeclarationSerializer.Deserialize(Accelbuffer.AccelReader@)">
            <summary>
            反序列化方法（自动生成）
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.Declarations.UsingDeclaration">
            <summary>
            包引用声明
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.Declarations.UsingDeclaration.PackageName">
            <summary>
            引用的包名
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.UsingDeclaration.ToBytes">
            <summary>
            序列化对象
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.UsingDeclaration.FromBytes(System.Byte[])">
            <summary>
            反序列化对象
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.Declarations.UsingDeclaration.UsingDeclarationSerializer">
            <summary>
            对象序列化代理（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.UsingDeclaration.UsingDeclarationSerializer.Serialize(Accelbuffer.Compiling.Declarations.UsingDeclaration,Accelbuffer.AccelWriter@)">
            <summary>
            序列化方法（自动生成）
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Declarations.UsingDeclaration.UsingDeclarationSerializer.Deserialize(Accelbuffer.AccelReader@)">
            <summary>
            反序列化方法（自动生成）
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.Declarations.IDeclaration">
            <summary>
            表示一个声明
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.KeywordCategory">
            <summary>
            指示一个关键字的类别
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.KeywordCategory.Other">
            <summary>
            其他类型
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.KeywordCategory.TypeKeyword">
            <summary>
            类型关键字
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.KeywordCategory.StructModifier">
            <summary>
            结构描述关键字
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.TokenType">
            <summary>
            指示一个标记的类型
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Invalid">
            <summary>
            无效值
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Document">
            <summary>
            文档
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.OpenBrace">
            <summary>
            '{'
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.CloseBrace">
            <summary>
            '}'
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.OpenBracket">
            <summary>
            '['
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.CloseBracket">
            <summary>
            ']'
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.OpenParen">
            <summary>
            '('
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.CloseParen">
            <summary>
            ')'
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Semicolon">
            <summary>
            ';'
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Bar">
            <summary>
            '|'
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Asterisk">
            <summary>
            '*'
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Question">
            <summary>
            '?'
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Colon">
            <summary>
            ':'
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Dot">
            <summary>
            '.'
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Comma">
            <summary>
            ','
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.GreaterThan">
            <summary>
            '&gt;'
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.LessThan">
            <summary>
            '&lt;'
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.IntLiteral">
            <summary>
            整数值
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Identifier">
            <summary>
            标识符
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.PackageKeyword">
            <summary>
            package
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.UsingKeyword">
            <summary>
            using
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.PublicKeyword">
            <summary>
            public
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.InternalKeyword">
            <summary>
            internal
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.PrivateKeyword">
            <summary>
            private
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.ProtectedKeyword">
            <summary>
            protected
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.FinalKeyword">
            <summary>
            final
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.RefKeyword">
            <summary>
            ref
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.StructKeyword">
            <summary>
            struct
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.AboutKeyword">
            <summary>
            about
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.VarKeyword">
            <summary>
            var
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.ObsoleteKeyword">
            <summary>
            obsolete
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.BooleanKeyword">
            <summary>
            boolean
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Int8Keyword">
            <summary>
            int8
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.UInt8Keyword">
            <summary>
            uint8
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Int16Keyword">
            <summary>
            int16
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.UInt16Keyword">
            <summary>
            uint16
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Int32Keyword">
            <summary>
            int32
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.UInt32Keyword">
            <summary>
            uint32
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Int64Keyword">
            <summary>
            int64
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.UInt64Keyword">
            <summary>
            uint64
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Float32Keyoword">
            <summary>
            float32
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Float64Keyword">
            <summary>
            float64
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.Float128Keyword">
            <summary>
            float128
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.CharKeyword">
            <summary>
            char
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.StringKeyword">
            <summary>
            string
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.NIntKeyword">
            <summary>
            nint
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.NUIntKeyword">
            <summary>
            nuint
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.VIntKeyword">
            <summary>
            vint
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.TokenType.VUIntKeyword">
            <summary>
            vuint
            </summary>
        </member>
        <member name="T:Accelbuffer.Compiling.ErrorWriter">
            <summary>
            表示一个输出错误信息的编写器。 此类为抽象类。
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.ErrorWriter.IsError">
            <summary>
            获取是否输出过错误
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.ErrorWriter.#ctor">
            <summary>
            初始化 ErrorWriter
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.ErrorWriter.Reset">
            <summary>
            重置该对象
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.ErrorWriter.LogError(System.String,Accelbuffer.Compiling.Token)">
            <summary>
            输出一个错误
            </summary>
            <param name="msg">消息字符串</param>
            <param name="token">导致错误的标记</param>
        </member>
        <member name="M:Accelbuffer.Compiling.ErrorWriter.LogError(System.String,System.String,System.Int32,System.Int32,System.Object[])">
            <summary>
            输出一个错误
            </summary>
            <param name="msg">消息字符串</param>
            <param name="filePath">文件所在路径</param>
            <param name="line">错误所在行号</param>
            <param name="column">错误所在列号</param>
            <param name="args">字符串格式化参数</param>
        </member>
        <member name="M:Accelbuffer.Compiling.ErrorWriter.LogWarning(System.String,Accelbuffer.Compiling.Token)">
            <summary>
            输出一个警告
            </summary>
            <param name="msg">消息字符串</param>
            <param name="token">导致警告的标记</param>
        </member>
        <member name="M:Accelbuffer.Compiling.ErrorWriter.LogWarning(System.String,Accelbuffer.Compiling.Token,System.Object[])">
            <summary>
            输出一个警告
            </summary>
            <param name="msg">消息字符串</param>
            <param name="token">导致警告的标记</param>
            <param name="args">字符串格式化参数</param>
        </member>
        <member name="M:Accelbuffer.Compiling.ErrorWriter.LogErrorMessage(System.String,System.String,System.Int32,System.Int32,System.Object[])">
            <summary>
            输出一个错误
            </summary>
            <param name="msg">消息字符串</param>
            <param name="filePath">文件所在路径</param>
            <param name="line">错误所在行号</param>
            <param name="column">错误所在列号</param>
            <param name="args">字符串格式化参数</param>
        </member>
        <member name="M:Accelbuffer.Compiling.ErrorWriter.LogWarning(System.String,System.String,System.Int32,System.Int32,System.Object[])">
            <summary>
            输出一个警告
            </summary>
            <param name="msg">消息字符串</param>
            <param name="filePath">文件所在路径</param>
            <param name="line">警告所在行号</param>
            <param name="column">警告所在列号</param>
            <param name="args">字符串格式化参数</param>
        </member>
        <member name="T:Accelbuffer.Compiling.KeywordManager">
            <summary>
            表示一个关键字管理器
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.KeywordManager.Default">
            <summary>
            获取默认的关键字管理器
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.KeywordManager.#ctor">
            <summary>
            初始化 KeywordManager
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.KeywordManager.RegisterKeyword(System.String,Accelbuffer.Compiling.TokenType,Accelbuffer.Compiling.KeywordCategory)">
            <summary>
            注册一个关键字
            </summary>
            <param name="raw">关键字的字符串形式</param>
            <param name="type">关键字所属的标记类型</param>
            <param name="category">关键字的类别</param>
        </member>
        <member name="M:Accelbuffer.Compiling.KeywordManager.IsInCategory(System.String,Accelbuffer.Compiling.KeywordCategory)">
            <summary>
            获取关键字是否在指定的类别中
            </summary>
            <param name="raw">关键字的字符串形式</param>
            <param name="category">查询的关键字类别</param>
            <returns>如果关键字在<paramref name="category"/>类别中，返回true，否则false</returns>
        </member>
        <member name="M:Accelbuffer.Compiling.KeywordManager.TryMatchKeyword(System.String,Accelbuffer.Compiling.TokenType@,Accelbuffer.Compiling.KeywordCategory@)">
            <summary>
            尝试匹配关键字的标记类型
            </summary>
            <param name="raw">关键字的字符串形式</param>
            <param name="type">关键字的标记类型</param>
            <param name="category">关键字的类别</param>
            <returns>如果匹配成功，返回true，否则false</returns>
        </member>
        <member name="T:Accelbuffer.Compiling.LanguageManager">
            <summary>
            表示一个目标语言管理器
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.LanguageManager.AccelbufferByteCode">
            <summary>
            AccelbufferByteCode管理器
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.LanguageManager.VisualBasic">
            <summary>
            VisualBasic管理器
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.LanguageManager.CSharp">
            <summary>
            C#管理器
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.LanguageManager.CPP">
            <summary>
            C++管理器
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.LanguageManager.Java">
            <summary>
            Java管理器
            </summary>
        </member>
        <member name="P:Accelbuffer.Compiling.LanguageManager.Entension">
            <summary>
            获取该语言源文件的后缀名
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.LanguageManager.#ctor">
            <summary>
            初始化 LanguageManager
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.LanguageManager.ChangeExtension(System.String)">
            <summary>
            切换文件路径的后缀名为目标语言源文件的后缀名
            </summary>
            <param name="filePath">文件路径</param>
            <returns>修改后的文件路径</returns>
        </member>
        <member name="M:Accelbuffer.Compiling.LanguageManager.GenerateCode(Accelbuffer.Compiling.DeclarationArray,System.IO.StreamWriter)">
            <summary>
            生成目标语言的代码
            </summary>
            <param name="declarations">定义列表</param>
            <param name="writer">数据写入器</param>
        </member>
        <member name="T:Accelbuffer.Compiling.Parser">
            <summary>
            表示一个语法分析器，用于将标记转换为定义列表
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Parser.#ctor(Accelbuffer.Compiling.ErrorWriter,Accelbuffer.Compiling.KeywordManager)">
            <summary>
            初始化 Parser
            </summary>
            <param name="writer">错误编写器</param>
            <param name="keywordManager">关键字管理器</param>
        </member>
        <member name="M:Accelbuffer.Compiling.Parser.Reset(Accelbuffer.Compiling.Token[])">
            <summary>
            重置 Parser
            </summary>
            <param name="tokens">由<see cref="T:Accelbuffer.Compiling.Scanner"/>分析得到的标记数组</param>
        </member>
        <member name="M:Accelbuffer.Compiling.Parser.ToDeclaration">
            <summary>
            将所有标记分析为一个声明列表
            </summary>
            <returns>分析完成的声明列表，包含了文件中所有的定义信息</returns>
        </member>
        <member name="T:Accelbuffer.Compiling.Scanner">
            <summary>
            表示一个字符扫描器，用于将文件转化为一系列标记
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Scanner.#ctor(Accelbuffer.Compiling.ErrorWriter,Accelbuffer.Compiling.KeywordManager)">
            <summary>
            初始化Scanner
            </summary>
            <param name="writer">错误编写器</param>
            <param name="manager">关键字管理器</param>
        </member>
        <member name="M:Accelbuffer.Compiling.Scanner.Reset(System.String,System.IO.StreamReader)">
            <summary>
            重置Scanner
            </summary>
            <param name="filePath">扫描的文件路径</param>
            <param name="reader">文件内容读取器</param>
        </member>
        <member name="M:Accelbuffer.Compiling.Scanner.ToTokens">
            <summary>
            扫描文件并转换为一系列的标记
            </summary>
            <returns>从文件中读取的标记</returns>
        </member>
        <member name="T:Accelbuffer.Compiling.Token">
            <summary>
            表示一个标记
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.Token.Raw">
            <summary>
            获取原始字符串
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.Token.Type">
            <summary>
            获取标记的类型
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.Token.Line">
            <summary>
            获取标记所在的行号
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.Token.Column">
            <summary>
            获取标记所在的列号
            </summary>
        </member>
        <member name="F:Accelbuffer.Compiling.Token.FilePath">
            <summary>
            获取标记所在的文件路径
            </summary>
        </member>
        <member name="M:Accelbuffer.Compiling.Token.#ctor(System.String,Accelbuffer.Compiling.TokenType,System.Int32,System.Int32,System.String)">
            <summary>
            创建一个新的标记
            </summary>
            <param name="raw">原始字符串</param>
            <param name="type">标记的类型</param>
            <param name="line">标记所在的行号</param>
            <param name="column">标记所在的列号</param>
            <param name="filePath">标记所在的文件路径</param>
        </member>
        <member name="T:Accelbuffer.Injection.IL.RuntimeInjector">
            <summary>
            提供在运行时注入类型的接口
            </summary>
        </member>
        <member name="M:Accelbuffer.Injection.IL.RuntimeInjector.DefinePublicType(System.String,System.Boolean,System.Reflection.Emit.TypeBuilder,System.Type,System.Type[])">
            <summary>
            定义一个新的公开类型
            </summary>
            <param name="name">类型的名称</param>
            <param name="isSealed">指示类型是否是密封类型</param>
            <param name="declaringTypeBuilder">声明此类型的类型构造器，如果这个值不为null，则类型是嵌套类型</param>
            <param name="baseType">类型的基类，如果是值类型，应该传入<see cref="T:System.ValueType"/></param>
            <param name="interfaces">类型实现的所有接口</param>
            <returns>新类型的构造器</returns>
        </member>
        <member name="M:Accelbuffer.Injection.IL.RuntimeInjector.DefineSerializerType(System.Type,System.Type@)">
            <summary>
            创建给定类型的序列化代理类型
            </summary>
            <param name="objType">该序列化代理序列化的对象类型</param>
            <param name="interfaceType">该序列化代理序列化实现的接口类型，为<see cref="T:Accelbuffer.ITypeSerializer`1"/>的封闭类型</param>
            <returns>序列化代理类型的构造器</returns>
        </member>
        <member name="M:Accelbuffer.Injection.IL.RuntimeInjector.GetSerializerName(System.Type)">
            <summary>
            获取给定类型的序列化代理名称
            </summary>
            <param name="objType">该序列化代理序列化的对象类型</param>
            <returns>给定类型的序列化代理名称</returns>
        </member>
        <member name="M:Accelbuffer.Injection.IL.RuntimeInjector.DefineSerializeMethod(System.Reflection.Emit.TypeBuilder,System.Type,System.Type)">
            <summary>
            为给定的序列化代理创建<see cref="M:Accelbuffer.ITypeSerializer`1.Serialize(`0,Accelbuffer.AccelWriter@)"/>方法
            </summary>
            <param name="serializerTypeBuilder">序列化代理类型的构造器</param>
            <param name="objType">该序列化代理序列化的对象类型</param>
            <param name="interfaceType">该序列化代理序列化实现的接口类型，应该为<see cref="T:Accelbuffer.ITypeSerializer`1"/>的封闭类型</param>
            <returns><see cref="M:Accelbuffer.ITypeSerializer`1.Serialize(`0,Accelbuffer.AccelWriter@)"/>方法的构造器</returns>
        </member>
        <member name="M:Accelbuffer.Injection.IL.RuntimeInjector.DefineDeserializeMethod(System.Reflection.Emit.TypeBuilder,System.Type,System.Type)">
            <summary>
            为给定的序列化代理创建<see cref="M:Accelbuffer.ITypeSerializer`1.Deserialize(Accelbuffer.AccelReader@)"/>方法
            </summary>
            <param name="serializerTypeBuilder">序列化代理类型的构造器</param>
            <param name="objType">该序列化代理序列化的对象类型</param>
            <param name="interfaceType">该序列化代理序列化实现的接口类型，应该为<see cref="T:Accelbuffer.ITypeSerializer`1"/>的封闭类型</param>
            <returns><see cref="M:Accelbuffer.ITypeSerializer`1.Deserialize(Accelbuffer.AccelReader@)"/>方法的构造器</returns>
        </member>
        <member name="M:Accelbuffer.Injection.IL.RuntimeInjector.SaveAssembly">
            <summary>
            保存程序集至磁盘，名称为DynamicAssembly.dll和RuntimeTypes.dll。
            这个方法只在DEBUG下执行。
            </summary>
        </member>
        <member name="P:Accelbuffer.Injection.IL.Serializers.Progress.SerializerGenerationProgress.WriteValueGenericMethod">
            <summary>
            <see cref="M:Accelbuffer.AccelWriter.WriteValue``1(System.Int32,``0)"/>
            </summary>
        </member>
        <member name="P:Accelbuffer.Injection.IL.Serializers.Progress.SerializerGenerationProgress.HasNextMethod">
            <summary>
            <see cref="M:Accelbuffer.AccelReader.HasNext(System.Int32@)"/>
            </summary>
        </member>
        <member name="P:Accelbuffer.Injection.IL.Serializers.Progress.SerializerGenerationProgress.SkipNextMethod">
            <summary>
            <see cref="M:Accelbuffer.AccelReader.SkipNext"/>
            </summary>
        </member>
        <member name="P:Accelbuffer.Injection.IL.Serializers.Progress.SerializerGenerationProgress.ReadGenericMethod">
            <summary>
            <see cref="M:Accelbuffer.AccelReader.ReadGeneric``1"/>
            </summary>
        </member>
        <member name="T:Accelbuffer.Injection.FacadeTypeAttribute">
            <summary>
            指示一个字段使用外观类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Injection.FacadeTypeAttribute.RealType">
            <summary>
            字段的真实类型。
            在序列化时，字段会被强制转换为该类型。
            在反序列化时，字段会从该类型强制转换为原类型。
            </summary>
        </member>
        <member name="M:Accelbuffer.Injection.FacadeTypeAttribute.#ctor(System.Type)">
            <summary>
            初始化 FacadeTypeAttribute
            </summary>
            <param name="realType">
            字段的真实类型。
            在序列化时，字段会被强制转换为该类型。
            在反序列化时，字段会从该类型强制转换为原类型。
            </param>
        </member>
        <member name="T:Accelbuffer.Injection.NeverNullAttribute">
            <summary>
            指示在序列化时这个字段的值永远不会是null。
            标记了这个特性的字段在写入时不会进行null检查
            </summary>
        </member>
        <member name="T:Accelbuffer.Injection.OnAfterDeserializationAttribute">
            <summary>
            指定一个方法为反序列化后的回调方法
            </summary>
        </member>
        <member name="T:Accelbuffer.Injection.OnBeforeSerializationAttribute">
            <summary>
            指定一个方法为序列化前的回调方法
            </summary>
        </member>
        <member name="T:Accelbuffer.Injection.SerialIndexAttribute">
            <summary>
            指示字段的序列索引，只有标记了这个特性的字段才会参与序列化
            </summary>
        </member>
        <member name="P:Accelbuffer.Injection.SerialIndexAttribute.Index">
            <summary>
            获取字段的序列索引
            </summary>
        </member>
        <member name="M:Accelbuffer.Injection.SerialIndexAttribute.#ctor(System.Int32)">
            <summary>
            初始化 SerialIndexAttribute 实例
            </summary>
            <param name="index">
            字段的序列索引，必须是 (0, 268435456] 范围内的整数；
            如果可能，索引应该尽可能全部连续（以1递增或递减）
            </param>
        </member>
        <member name="T:Accelbuffer.Injection.SerializerBinder">
            <summary>
            公开对序列化代理的绑定接口
            </summary>
        </member>
        <member name="M:Accelbuffer.Injection.SerializerBinder.AddBinding``2">
            <summary>
            添加一个序列化代理的绑定，如果已经存在，则覆盖
            </summary>
            <typeparam name="TObject">序列化对象类型</typeparam>
            <typeparam name="TSerializer">被绑定的代理类型</typeparam>
        </member>
        <member name="M:Accelbuffer.Injection.SerializerBinder.AddBinding(System.Type,System.Type)">
            <summary>
            添加一个序列化代理的绑定，如果已经存在，则覆盖
            </summary>
            <param name="objectType">序列化对象类型</param>
            <param name="serializerType">被绑定的代理类型</param>
            <exception cref="T:Accelbuffer.SerializerTypeException"><paramref name="serializerType"/>类型错误</exception>
        </member>
        <member name="M:Accelbuffer.Injection.SerializerBinder.HasBinding``1(System.Boolean)">
            <summary>
            获取是否已经存在绑定
            </summary>
            <typeparam name="TObject">序列化对象类型</typeparam>
            <param name="checkAttribute">指示是否检查类型的<see cref="T:Accelbuffer.SerializeByAttribute"/></param>
            <returns>如果已经存在，返回true，否则，false</returns>
        </member>
        <member name="M:Accelbuffer.Injection.SerializerBinder.HasBinding(System.Type,System.Boolean)">
            <summary>
            获取是否已经存在绑定
            </summary>
            <param name="objectType">序列化对象类型</param>
            <param name="checkAttribute">指示是否检查类型的<see cref="T:Accelbuffer.SerializeByAttribute"/></param>
            <returns>如果已经存在，返回true，否则，false</returns>
        </member>
        <member name="T:Accelbuffer.Reflection.AccelFieldInfo">
            <summary>
            表示一个结构中的字段。
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelFieldInfo.FieldHandle">
            <summary>
            获取内部元数据字段的表示形式的句柄
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelFieldInfo.Info">
            <summary>
            获取字段的元数据类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelFieldInfo.Name">
            <summary>
            获取字段的名称
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelFieldInfo.Document">
            <summary>
            获取字段的文档
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelFieldInfo.SerialIndex">
            <summary>
            获取字段的序列索引
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelFieldInfo.IsObsolete">
            <summary>
            获取字段是否已经被弃用
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelFieldInfo.IsNeverNull">
            <summary>
            获取字段的值是否永远不会为null
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelFieldInfo.IsFacadeType">
            <summary>
            获取字段是否使用外观类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelFieldInfo.DeclaringType">
            <summary>
            获取声明此字段的类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelFieldInfo.FieldType">
            <summary>
            获取字段的类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelFieldInfo.RealFieldType">
            <summary>
            获取字段的真实类型，如果字段没有使用外观类型，将返回null
            </summary>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelFieldInfo.ToString">
            <summary>
            返回<see cref="P:Accelbuffer.Reflection.AccelFieldInfo.Name"/>
            </summary>
            <returns><see cref="P:Accelbuffer.Reflection.AccelFieldInfo.Name"/></returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelFieldInfo.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelFieldInfo.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelFieldInfo.Equals(Accelbuffer.Reflection.AccelFieldInfo)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelFieldInfo.GetValue(System.Object)">
            <summary>
            返回给定对象的字段的值
            </summary>
            <param name="obj">获取字段值的对象引用</param>
            <returns>给定对象的字段的值</returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelFieldInfo.SetValue(System.Object,System.Object)">
            <summary>
            设置给定对象的字段的值。
            </summary>
            <param name="obj">设置字段值的对象引用</param>
            <param name="value">要分配给字段的值</param>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelFieldInfo.op_Equality(Accelbuffer.Reflection.AccelFieldInfo,Accelbuffer.Reflection.AccelFieldInfo)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelFieldInfo.op_Inequality(Accelbuffer.Reflection.AccelFieldInfo,Accelbuffer.Reflection.AccelFieldInfo)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:Accelbuffer.Reflection.AccelTypeInfo">
            <summary>
            表示一个结构类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.TypeHandle">
            <summary>
            获取内部元数据类型的表示形式的句柄
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.Info">
            <summary>
            获取类型的元数据类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.Name">
            <summary>
            获取类型的名称
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.FullName">
            <summary>
            获取类型的全名
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.Document">
            <summary>
            获取类型的文档
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.Visibility">
            <summary>
            获取类型的可访问性
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.IsFinal">
            <summary>
            获取类型是否是密封类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.IsClass">
            <summary>
            获取类型是否是引用类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.IsValueType">
            <summary>
            获取类型是否是值类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.IsNested">
            <summary>
            获取类型是否是嵌套类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.HasContinuousSerialIndexes">
            <summary>
            获取类型中的字段的序列索引是否连续
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.ApproximateMemorySize">
            <summary>
            获取类型的实例将会占用的近似字节大小
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.DeclaringType">
            <summary>
            获取声明此类型的类型
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.Fields">
            <summary>
            获取类型声明的所有字段
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.OnBeforeSerializeMethod">
            <summary>
            获取类型声明的序列化前调用的方法
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.AccelTypeInfo.OnAfterDeserializeMethod">
            <summary>
            获取类型声明的反序列化后调用的方法
            </summary>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelTypeInfo.ToString">
            <summary>
            返回<see cref="P:Accelbuffer.Reflection.AccelTypeInfo.FullName"/>
            </summary>
            <returns><see cref="P:Accelbuffer.Reflection.AccelTypeInfo.FullName"/></returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelTypeInfo.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelTypeInfo.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelTypeInfo.Equals(Accelbuffer.Reflection.AccelTypeInfo)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelTypeInfo.CreateInstance">
            <summary>
            创建类型的一个实例
            </summary>
            <returns>该类型的实例对象</returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelTypeInfo.GetFields">
            <summary>
            获取类型声明的所有字段
            </summary>
            <returns>类型声明的所有字段的枚举对象</returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelTypeInfo.GetField(System.String)">
            <summary>
            获取类型中指定名称的字段
            </summary>
            <param name="name">需要获取的字段的名称</param>
            <returns>类型中具有指定名称的字段，如果字段不存在，则返回null</returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelTypeInfo.GetTypes">
            <summary>
            获取加载的所有类型元数据
            </summary>
            <returns>类型元数据枚举</returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelTypeInfo.GetType(System.String)">
            <summary>
            获取具有给定名称的类型元数据
            </summary>
            <param name="name">需要查询的类型名称（FullName）</param>
            <returns>具有给定名称的类型元数据</returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelTypeInfo.GetTypeInfo(System.Type,System.Collections.Generic.IEnumerable{Accelbuffer.Reflection.AccelFieldInfo}@,System.Reflection.MethodInfo@,System.Reflection.MethodInfo@,System.Int32@,System.Boolean@)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="fields"></param>
            <param name="before"></param>
            <param name="after"></param>
            <param name="fieldCount"></param>
            <param name="hasContinuousSerialIndexes"></param>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelTypeInfo.GetTypeInfo(Accelbuffer.Reflection.AccelTypeInfo,System.Collections.Generic.IEnumerable{Accelbuffer.Reflection.AccelFieldInfo}@,System.Reflection.MethodInfo@,System.Reflection.MethodInfo@,System.Int32@,System.Boolean@)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="fields"></param>
            <param name="before"></param>
            <param name="after"></param>
            <param name="fieldCount"></param>
            <param name="hasContinuousSerialIndexes"></param>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelTypeInfo.op_Equality(Accelbuffer.Reflection.AccelTypeInfo,Accelbuffer.Reflection.AccelTypeInfo)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.Reflection.AccelTypeInfo.op_Inequality(Accelbuffer.Reflection.AccelTypeInfo,Accelbuffer.Reflection.AccelTypeInfo)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:Accelbuffer.Reflection.TypeVisibility">
            <summary>
            表示一个类型的可访问性
            </summary>
        </member>
        <member name="F:Accelbuffer.Reflection.TypeVisibility.None">
            <summary>
            无
            </summary>
        </member>
        <member name="F:Accelbuffer.Reflection.TypeVisibility.Public">
            <summary>
            public
            </summary>
        </member>
        <member name="F:Accelbuffer.Reflection.TypeVisibility.Internal">
            <summary>
            internal
            </summary>
        </member>
        <member name="F:Accelbuffer.Reflection.TypeVisibility.Private">
            <summary>
            private
            </summary>
        </member>
        <member name="F:Accelbuffer.Reflection.TypeVisibility.Protected">
            <summary>
            protected
            </summary>
        </member>
        <member name="F:Accelbuffer.Reflection.TypeVisibility.ProtectedInternal">
            <summary>
            protected internal
            </summary>
        </member>
        <member name="F:Accelbuffer.Reflection.TypeVisibility.PrivateProtected">
            <summary>
            private protected
            </summary>
        </member>
        <member name="T:Accelbuffer.Reflection.IAccelMemberInfo">
            <summary>
            表示一个成员
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.IAccelMemberInfo.Name">
            <summary>
            获取成员的名称
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.IAccelMemberInfo.Document">
            <summary>
            获取成员的文档
            </summary>
        </member>
        <member name="P:Accelbuffer.Reflection.IAccelMemberInfo.DeclaringType">
            <summary>
            获取声明此成员的类型
            </summary>
        </member>
        <member name="T:Accelbuffer.InvalidFieldIndexException">
            <summary>
            无效的字段索引错误
            </summary>
        </member>
        <member name="M:Accelbuffer.InvalidFieldIndexException.#ctor">
            <summary>
            初始化 InvalidFieldIndexException
            </summary>
        </member>
        <member name="M:Accelbuffer.InvalidFieldIndexException.#ctor(System.String)">
            <summary>
            初始化 InvalidFieldIndexException
            </summary>
            <param name="message">描述错误的消息</param>
        </member>
        <member name="M:Accelbuffer.InvalidFieldIndexException.#ctor(System.String,System.Exception)">
            <summary>
            初始化 InvalidFieldIndexException
            </summary>
            <param name="message">描述错误的消息</param>
            <param name="inner">导致当前异常的异常；如果未指定内部异常，则是一个 null 引用（在 Visual Basic 中为 Nothing）。</param>
        </member>
        <member name="T:Accelbuffer.InvalidUTF8CharException">
            <summary>
            无效的UTF8字符错误
            </summary>
        </member>
        <member name="M:Accelbuffer.InvalidUTF8CharException.#ctor">
            <summary>
            初始化 InvalidUTF8CharException
            </summary>
        </member>
        <member name="M:Accelbuffer.InvalidUTF8CharException.#ctor(System.String)">
            <summary>
            初始化 InvalidUTF8CharException
            </summary>
            <param name="message">描述错误的消息</param>
        </member>
        <member name="M:Accelbuffer.InvalidUTF8CharException.#ctor(System.String,System.Exception)">
            <summary>
            初始化 InvalidUTF8CharException
            </summary>
            <param name="message">描述错误的消息</param>
            <param name="inner">导致当前异常的异常；如果未指定内部异常，则是一个 null 引用（在 Visual Basic 中为 Nothing）。</param>
        </member>
        <member name="T:Accelbuffer.SerializerTypeException">
            <summary>
            序列化代理类型错误
            </summary>
        </member>
        <member name="M:Accelbuffer.SerializerTypeException.#ctor">
            <summary>
            初始化 SerializerTypeException
            </summary>
        </member>
        <member name="M:Accelbuffer.SerializerTypeException.#ctor(System.String)">
            <summary>
            初始化 SerializerTypeException
            </summary>
            <param name="message">描述错误的消息</param>
        </member>
        <member name="M:Accelbuffer.SerializerTypeException.#ctor(System.String,System.Exception)">
            <summary>
            初始化 SerializerTypeException
            </summary>
            <param name="message">描述错误的消息</param>
            <param name="inner">导致当前异常的异常；如果未指定内部异常，则是一个 null 引用（在 Visual Basic 中为 Nothing）。</param>
        </member>
        <member name="T:Accelbuffer.Memory.NativeBuffer">
            <summary>
            表示一个非托管缓冲区
            </summary>
        </member>
        <member name="P:Accelbuffer.Memory.NativeBuffer.Length">
            <summary>
            获取缓冲区的长度
            </summary>
        </member>
        <member name="P:Accelbuffer.Memory.NativeBuffer.Disposed">
            <summary>
            获取缓冲区是否被释放
            </summary>
        </member>
        <member name="P:Accelbuffer.Memory.NativeBuffer.Item(System.Int32)">
            <summary>
            获取/设置缓冲区指定索引的值
            </summary>
            <param name="index">数据的索引</param>
            <returns>索引处的数据</returns>
            <exception cref="T:System.ObjectDisposedException">当前对象已经被释放</exception>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="index"/>超出范围</exception>
        </member>
        <member name="M:Accelbuffer.Memory.NativeBuffer.Dispose">
            <summary>
            释放缓冲区内存
            </summary>
        </member>
        <member name="M:Accelbuffer.Memory.NativeBuffer.ToArray">
            <summary>
            将缓冲区转换为托管字节数组
            </summary>
            <returns>与当前对象等价的托管字节数组</returns>
            <exception cref="T:System.ObjectDisposedException">当前对象已经被释放</exception>
        </member>
        <member name="M:Accelbuffer.Memory.NativeBuffer.CopyToArray(System.Byte[],System.Int32)">
            <summary>
            将缓冲区数据拷贝到托管字节数组中
            </summary>
            <param name="buffer">拷贝到的托管字节数组</param>
            <param name="startIndex">开始写入的索引位置</param>
            <returns>写入的数据长度</returns>
            <exception cref="T:System.ObjectDisposedException">当前对象已经被释放</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="buffer"/>是null</exception>
            <exception cref="T:System.ArgumentException"><paramref name="buffer"/>长度不足</exception>
        </member>
        <member name="M:Accelbuffer.Memory.NativeBuffer.GetEnumerator">
            <summary>
            遍历缓冲区的所有数据
            </summary>
            <returns>数据迭代器</returns>
        </member>
        <member name="M:Accelbuffer.Memory.NativeBuffer.op_Explicit(Accelbuffer.Memory.NativeBuffer)~System.Byte*">
            <summary>
            获取对象内部维护的指针
            </summary>
            <param name="buffer">需要获取指针的对象</param>
        </member>
        <member name="M:Accelbuffer.Memory.NativeBuffer.op_Implicit(Accelbuffer.Memory.NativeBuffer)~System.Boolean">
            <summary>
            获取对象是否没有被释放
            </summary>
            <param name="buffer">需要查询状态的对象</param>
        </member>
        <member name="T:Accelbuffer.Memory.NativeMemory">
            <summary>
            表示一段自动变长的非托管内存
            </summary>
        </member>
        <member name="P:Accelbuffer.Memory.NativeMemory.Size">
            <summary>
            获取当前内存的大小，以字节为单位
            </summary>
        </member>
        <member name="M:Accelbuffer.Memory.NativeMemory.Dispose">
            <summary>
            释放内存
            </summary>
        </member>
        <member name="M:Accelbuffer.Memory.NativeMemory.GetPointer">
            <summary>
            获取内存的指针
            </summary>
            <returns>指向内存的指针，如果是null，则对象已经被释放或者内存大小为0</returns>
        </member>
        <member name="M:Accelbuffer.Memory.NativeMemory.GetPointer(System.Int32)">
            <summary>
            获取内存的指针，且保证内存的大小至少是<paramref name="minSize"/>
            </summary>
            <param name="minSize">获取的内存的最小值，以字节为单位</param>
            <returns>指向内存的指针</returns>
            <exception cref="T:System.ObjectDisposedException">当前内存已经被释放或者内存大小为0</exception>
        </member>
        <member name="M:Accelbuffer.Memory.NativeMemory.ToNativeBufferNoCopy(System.Int32)">
            <summary>
            将当前内存转换为一个非托管缓冲区。
            这个方法不会开辟新的内存，
            所以如果要继续使用返回的<see cref="T:Accelbuffer.Memory.NativeBuffer"/>就不应该调用<see cref="M:Accelbuffer.Memory.NativeMemory.Dispose"/>方法，
            如果需要释放这块内存，只需要调用<see cref="M:Accelbuffer.Memory.NativeBuffer.Dispose"/>和<see cref="M:Accelbuffer.Memory.NativeMemory.Dispose"/>其中一个
            </summary>
            <param name="usedSize">暴露给非托管缓冲区使用的字节大小</param>
            <returns>与当前对象等效的非托管缓冲区</returns>
            <exception cref="T:System.ObjectDisposedException">当前内存已经被释放或者内存大小为0</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="usedSize"/>是负数或者大于<see cref="P:Accelbuffer.Memory.NativeMemory.Size"/></exception>
        </member>
        <member name="M:Accelbuffer.Memory.NativeMemory.Allocate(System.Int32@)">
            <summary>
            分配一块可以自动变长的非托管内存
            </summary>
            <param name="size">内存的初始大小，这个值的大小在分配内存时可能被向上调整</param>
            <returns>内存对象</returns>
        </member>
        <member name="T:Accelbuffer.Memory.IMemorySizeForType`1">
            <summary>
            实现接口，在初始化时提供<typeparamref name="T"/>类型将占用内存的近似大小。
            如果实现这个接口的类型不实现<see cref="T:Accelbuffer.ITypeSerializer`1"/>，则这个接口的实现无效。
            在这个接口中设置的值的使用优先级大于使用<see cref="T:Accelbuffer.Memory.MemorySizeAttribute"/>设置的值。
            </summary>
            <typeparam name="T">目标类型</typeparam>
        </member>
        <member name="P:Accelbuffer.Memory.IMemorySizeForType`1.ApproximateMemorySize">
            <summary>
            获取类型的对象将会占用的近似字节大小，这个值必须大于0且应该尽可能返回准确的值。
            在序列化时，会使用这个值进行第一次的内存分配，如果数值合理，可以避免realloc和memcpy的时间损失。
            在类型的大小不固定时，如果这个值有一个上限，可以考虑使用这个上限值。
            </summary>
        </member>
        <member name="T:Accelbuffer.Memory.MemorySizeAttribute">
            <summary>
            设置类型的序列化/反序列化选项
            </summary>
        </member>
        <member name="P:Accelbuffer.Memory.MemorySizeAttribute.ApproximateMemorySize">
            <summary>
            获取类型的对象将会占用的近似字节大小。
            </summary>
        </member>
        <member name="M:Accelbuffer.Memory.MemorySizeAttribute.#ctor(System.Int32)">
            <summary>
            初始化MemorySizeAttribute实例
            </summary>
            <param name="approximateMemorySize">
            类型的对象将会占用的近似字节大小，这个值必须大于0且应该尽可能传入准确的值。
            在序列化时，会使用这个值进行第一次的内存分配，如果数值合理，可以避免realloc和memcpy的时间损失。
            在类型的大小不固定时，如果这个值有一个上限，可以考虑使用这个上限值。
            </param>
        </member>
        <member name="T:Accelbuffer.Memory.MemoryAllocator">
            <summary>
            表示一个非托管内存分配器
            </summary>
        </member>
        <member name="P:Accelbuffer.Memory.MemoryAllocator.Shared">
            <summary>
            获取全局共享的内存分配器实例
            </summary>
        </member>
        <member name="P:Accelbuffer.Memory.MemoryAllocator.MaxFindChunkCount">
            <summary>
            获取/设置分配内存时，寻找合适内存块的最大次数
            </summary>
        </member>
        <member name="P:Accelbuffer.Memory.MemoryAllocator.TotalMemorySizeInChunks">
            <summary>
            获取当前保存的所有内存块的总内存大小，以字节为单位
            </summary>
        </member>
        <member name="M:Accelbuffer.Memory.MemoryAllocator.Finalize">
            <summary>
            释放所有内存
            </summary>
        </member>
        <member name="M:Accelbuffer.Memory.MemoryAllocator.FreeMemory(System.Boolean)">
            <summary>
            释放内存
            </summary>
            <param name="leaveOneChunkEachSize">指示是否为每一种内存大小保留一个chunk</param>
        </member>
        <member name="M:Accelbuffer.Memory.MemoryAllocator.Allocate(System.Int32@)">
            <summary>
            分配指定字节大小的内存，内存没有被初始化，可能包含一些随机的数据
            </summary>
            <param name="size">需要分配的字节大小，这个值的大小在分配内存时可能被向上调整</param>
            <returns>分配的内存指针，如果为null，则分配失败</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size"/>是负数</exception>
            <exception cref="T:System.OutOfMemoryException">内存不足</exception>
        </member>
        <member name="M:Accelbuffer.Memory.MemoryAllocator.Free(System.Void*,System.Int32)">
            <summary>
            释放指定大小的内存
            </summary>
            <param name="p">指向内存的指针</param>
            <param name="size">内存的字节大小</param>
        </member>
        <member name="M:Accelbuffer.Memory.MemoryAllocator.Reallocate(System.Void*,System.Int32,System.Int32@)">
            <summary>
            重新分配一段内存的大小
            </summary>
            <param name="p">指向原内存的指针</param>
            <param name="oldSize">原内存的字节大小</param>
            <param name="newSize">新内存的字节大小，这个值的大小在重新分配内存时可能被向上调整</param>
            <returns>指向新内存的指针，如果为null，则分配失败</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/>为null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="oldSize"/>不是正数，或<paramref name="newSize"/>是负数</exception>
        </member>
        <member name="T:Accelbuffer.Endian">
            <summary>
            指示字节序
            </summary>
        </member>
        <member name="F:Accelbuffer.Endian.BigEndian">
            <summary>
            指示使用大端字节序（网络字节序）
            </summary>
        </member>
        <member name="F:Accelbuffer.Endian.LittleEndian">
            <summary>
            指示使用小端字节序
            </summary>
        </member>
        <member name="T:Accelbuffer.ObjectSerializationShortcut">
            <summary>
            提供更加方便的序列化对象的方法
            </summary>
        </member>
        <member name="M:Accelbuffer.ObjectSerializationShortcut.WriteToBuffer``1(``0,Accelbuffer.Encoding,Accelbuffer.Endian)">
            <summary>
            序列化对象，并返回序列化数据
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="obj">被序列化的对象</param>
            <param name="encoding">序列化使用的字符编码</param>
            <param name="endian">序列化使用的字节序</param>
            <returns>保存了对象序列化数据的一块非托管缓冲区</returns>
        </member>
        <member name="M:Accelbuffer.ObjectSerializationShortcut.WriteToBytes``1(``0,System.Byte[]@,Accelbuffer.Encoding,Accelbuffer.Endian)">
            <summary>
            序列化对象，并将序列化数据写入指定的缓冲区中
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="obj">被序列化的对象</param>
            <param name="buffer">对象的序列化结果</param>
            <param name="encoding">序列化使用的字符编码</param>
            <param name="endian">序列化使用的字节序</param>
        </member>
        <member name="M:Accelbuffer.ObjectSerializationShortcut.WriteToBytes``1(``0,System.Byte[],System.Int32,Accelbuffer.Encoding,Accelbuffer.Endian)">
            <summary>
            序列化对象，并将序列化数据写入指定的缓冲区中
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="obj">被序列化的对象</param>
            <param name="buffer">用于接受序列化数据的缓冲区</param>
            <param name="index"><paramref name="buffer"/>开始写入的索引</param>
            <param name="encoding">序列化使用的字符编码</param>
            <param name="endian">序列化使用的字节序</param>
            <returns>序列化数据的大小</returns>
            <exception cref="T:System.ArgumentException">字节数组容量不足</exception>
        </member>
        <member name="T:Accelbuffer.SerializationCallback`1">
            <summary>
            序列化/反序列化回调
            </summary>
            <typeparam name="T">序列化/反序列化的对象类型</typeparam>
            <param name="obj">序列化/反序列化的对象</param>
        </member>
        <member name="T:Accelbuffer.SerializationCallbackType">
            <summary>
            序列化/反序列化回调类型
            </summary>
        </member>
        <member name="F:Accelbuffer.SerializationCallbackType.OnBeforeSerialization">
            <summary>
            指示回调在序列化前调用
            </summary>
        </member>
        <member name="F:Accelbuffer.SerializationCallbackType.OnAfterSerialization">
            <summary>
            指示回调在反序列化后调用
            </summary>
        </member>
        <member name="T:Accelbuffer.Unsafe.NativeMemoryIO">
            <summary>
            提供一系列<see cref="T:Accelbuffer.Memory.NativeMemory"/>的便捷写入/读取方法
            </summary>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.ReadByte(Accelbuffer.Memory.NativeMemory@,System.Int32)">
            <summary>
            从内存中读取一个字节
            </summary>
            <param name="memory">保存了数据的一块非托管内存</param>
            <param name="offset">读取的偏移量</param>
            <returns>
            强制转换为<see cref="T:System.Int32"/>类型的字节对象，
            如果这个值为-1，则说明偏移处已经没有合法的字节可以读取
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/>是负数</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.ReadBytes(Accelbuffer.Memory.NativeMemory@,System.Int32,System.Int32)">
            <summary>
            从内存中读取指定数量的字节
            </summary>
            <param name="memory">保存了数据的一块非托管内存</param>
            <param name="offset">读取的偏移量</param>
            <param name="count">读取的字节数量</param>
            <returns>读取的所有字节</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/>是负数，或者<paramref name="count"/>是负数</exception>
            <exception cref="T:System.OutOfMemoryException"><paramref name="memory"/>中没有足够的大小用于读取</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.ReadBytes(Accelbuffer.Memory.NativeMemory@,System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            从内存中读取指定数量的字节，并写入指定内存中
            </summary>
            <param name="memory">保存了数据的一块非托管内存</param>
            <param name="offset">读取的偏移量</param>
            <param name="count">读取的字节数量</param>
            <param name="destination">用于接受读取的字节数组</param>
            <param name="destinationStartIndex">向<paramref name="destinationStartIndex"/>开始写入的索引</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="destination"/>是null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/>是负数，或者<paramref name="count"/>是负数</exception>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="destinationStartIndex"/>是负数</exception>
            <exception cref="T:System.OutOfMemoryException"><paramref name="memory"/>中没有足够的大小用于读取，或者<paramref name="destination"/>中没有足够的大小用于写入</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.ReadBytes(Accelbuffer.Memory.NativeMemory@,System.Int32,System.Int32,System.Byte*)">
            <summary>
            从内存中读取指定数量的字节，并写入指定内存中
            </summary>
            <param name="memory">保存了数据的一块非托管内存</param>
            <param name="offset">读取的偏移量</param>
            <param name="count">读取的字节数量</param>
            <param name="destination">用于接受读取的字节的内存的指针</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="destination"/>是null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/>是负数，或者<paramref name="count"/>是负数</exception>
            <exception cref="T:System.OutOfMemoryException"><paramref name="memory"/>中没有足够的大小用于读取</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.WriteByte(Accelbuffer.Memory.NativeMemory@,System.Int32,System.Byte)">
            <summary>
            向内存中写入一个字节
            </summary>
            <param name="memory">需要写入的非托管内存</param>
            <param name="offset">写入的偏移量</param>
            <param name="data">需要写入的字节</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/>是负数</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.WriteByte(Accelbuffer.Memory.NativeMemory@,System.Int32,System.Byte,System.Byte)">
            <summary>
            向内存中写入两个字节
            </summary>
            <param name="memory">需要写入的非托管内存</param>
            <param name="offset">写入的偏移量</param>
            <param name="arg0">需要写入的字节</param>
            <param name="arg1">需要写入的字节</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/>是负数</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.WriteByte(Accelbuffer.Memory.NativeMemory@,System.Int32,System.Byte,System.Byte,System.Byte)">
            <summary>
            向内存中写入三个字节
            </summary>
            <param name="memory">需要写入的非托管内存</param>
            <param name="offset">写入的偏移量</param>
            <param name="arg0">需要写入的字节</param>
            <param name="arg1">需要写入的字节</param>
            <param name="arg2">需要写入的字节</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/>是负数</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.WriteByte(Accelbuffer.Memory.NativeMemory@,System.Int32,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            向内存中写入四个字节
            </summary>
            <param name="memory">需要写入的非托管内存</param>
            <param name="offset">写入的偏移量</param>
            <param name="arg0">需要写入的字节</param>
            <param name="arg1">需要写入的字节</param>
            <param name="arg2">需要写入的字节</param>
            <param name="arg3">需要写入的字节</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/>是负数</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.WriteByte(Accelbuffer.Memory.NativeMemory@,System.Int32,System.Byte[])">
            <summary>
            向内存中写入数个字节
            </summary>
            <param name="memory">需要写入的非托管内存</param>
            <param name="offset">写入的偏移量</param>
            <param name="bytes">需要写入的字节</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/>是负数</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.WriteBytes(Accelbuffer.Memory.NativeMemory@,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            向内存中写入指定数量的字节
            </summary>
            <param name="memory">需要写入的非托管内存</param>
            <param name="offset">写入的偏移量</param>
            <param name="bytes">需要写入的字节数组</param>
            <param name="startIndex">读取<paramref name="bytes"/>的偏移量</param>
            <param name="count">需要写入的字节数量</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="bytes"/>为null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/>是负数，或者<paramref name="count"/>是负数</exception>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="startIndex"/>是负数</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.WriteBytes(Accelbuffer.Memory.NativeMemory@,System.Int32,System.Byte*,System.Int32)">
            <summary>
            向内存中写入指定数量的字节
            </summary>
            <param name="memory">需要写入的非托管内存</param>
            <param name="offset">写入的偏移量</param>
            <param name="bytes">需要写入的字节数组的指针</param>
            <param name="count">需要写入的字节数量</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="bytes"/>为null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/>是负数，或者<paramref name="count"/>是负数</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.CopyToNativeBuffer(Accelbuffer.Memory.NativeMemory@,System.Int32)">
            <summary>
            将当前内存转换为一个非托管缓冲区。
            这个方法会开辟新的内存，
            如果需要释放<paramref name="memory"/>的内存，可以调用<see cref="M:Accelbuffer.Memory.NativeMemory.Dispose"/>
            </summary>
            <param name="memory">需要拷贝的非托管内存</param>
            <param name="usedSize">暴露给非托管缓冲区使用的字节大小</param>
            <returns>与当前对象等效的非托管缓冲区</returns>
            <exception cref="T:System.ObjectDisposedException">当前内存已经被释放或者内存大小为0</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="usedSize"/>是负数或者大于<paramref name="memory"/>的大小</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.ToArray(Accelbuffer.Memory.NativeMemory@,System.Int32)">
            <summary>
            将一段非托管内存转换为托管字节数组
            </summary>
            <param name="memory">需要转换的非托管内存</param>
            <param name="size">转换的字节大小</param>
            <returns>保存了<paramref name="size"/>个来自<paramref name="memory"/>的字节的托管字节数组</returns>
        </member>
        <member name="M:Accelbuffer.Unsafe.NativeMemoryIO.CopyToArray(Accelbuffer.Memory.NativeMemory@,System.Int32,System.Byte[],System.Int32)">
            <summary>
            将一段非托管内存拷贝到指定的托管字节数组
            </summary>
            <param name="memory">需要拷贝的非托管内存</param>
            <param name="size">拷贝的字节数量</param>
            <param name="buffer">拷贝到的托管字节数组</param>
            <param name="startIndex">开始写入的索引位置</param>
            <returns>写入的数据长度</returns>
        </member>
        <member name="T:Accelbuffer.Unsafe.Text.Encodings">
            <summary>
            提供目前支持的字符串编码
            </summary>
        </member>
        <member name="P:Accelbuffer.Unsafe.Text.Encodings.ASCII">
            <summary>
            ASCII编码
            </summary>
        </member>
        <member name="P:Accelbuffer.Unsafe.Text.Encodings.Unicode">
            <summary>
            使用系统字节序的Unicode编码
            </summary>
        </member>
        <member name="P:Accelbuffer.Unsafe.Text.Encodings.ReversedUnicode">
            <summary>
            与系统字节序相反的Unicode编码
            </summary>
        </member>
        <member name="P:Accelbuffer.Unsafe.Text.Encodings.UTF8">
            <summary>
            UTF8编码
            </summary>
        </member>
        <member name="T:Accelbuffer.Unsafe.Text.IUnsafeEncoding">
            <summary>
            '不安全'的字符串编码转换器
            </summary>
        </member>
        <member name="M:Accelbuffer.Unsafe.Text.IUnsafeEncoding.GetBytes(System.String,System.Byte*)">
            <summary>
            将指定字符串中的一组字符编码为指定的字节数组
            </summary>
            <param name="str">字符串</param>
            <param name="buffer">字节数组指针</param>
            <returns>字节数量</returns>
        </member>
        <member name="M:Accelbuffer.Unsafe.Text.IUnsafeEncoding.GetString(System.Byte*,System.Int32)">
            <summary>
            将指定字节数组中的所有字节解码为一个字符串
            </summary>
            <param name="bytes">字节数组指针</param>
            <param name="byteCount">字节数量</param>
            <returns>解码的字符串</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount"/>的值错误</exception>
        </member>
        <member name="T:Accelbuffer.Unsafe.UnmanagedObjectSerializationShortcut">
            <summary>
            提供更加方便的序列化非托管对象的方法
            </summary>
        </member>
        <member name="M:Accelbuffer.Unsafe.UnmanagedObjectSerializationShortcut.WriteToBufferUnsafe``1(``0)">
            <summary>
            序列化对象，并返回序列化数据
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="obj">被序列化的对象</param>
            <returns>保存了对象序列化数据的一块非托管缓冲区</returns>
        </member>
        <member name="M:Accelbuffer.Unsafe.UnmanagedObjectSerializationShortcut.WriteToBytesUnsafe``1(``0,System.Byte[]@)">
            <summary>
            序列化对象，并将序列化数据写入指定的缓冲区中
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="obj">被序列化的对象</param>
            <param name="buffer">保存了对象序列化数据的缓冲区</param>
        </member>
        <member name="M:Accelbuffer.Unsafe.UnmanagedObjectSerializationShortcut.WriteToBytesUnsafe``1(``0,System.Byte[],System.Int32)">
            <summary>
            序列化对象，并将序列化数据写入指定的缓冲区中
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="obj">被序列化的对象</param>
            <param name="buffer">用于接受序列化数据的缓冲区</param>
            <param name="index">开始读取的索引位置</param>
            <returns>序列化数据的大小</returns>
            <exception cref="T:System.ArgumentException">字节数组容量不足</exception>
        </member>
        <member name="T:Accelbuffer.Unsafe.UnmanagedTypeSerializer">
            <summary>
            提供最快速的序列化非托管对象的接口，
            但是通过该接口序列化的数据不做任何优化，
            数据的大小等于对象类型的字节大小，
            字符的编码统一使用Unicode编码，
            字节序根据不同操作系统而不同。
            换句话说这个接口序列化类型时，
            只是一个memcpy的过程，
            如果需要更多功能支持，
            应该使用<see cref="T:Accelbuffer.Serializer"/>进行类型的序列化。
            </summary>
        </member>
        <member name="M:Accelbuffer.Unsafe.UnmanagedTypeSerializer.Serialize``1(``0)">
            <summary>
            序列化对象，并返回序列化数据
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="obj">被序列化的对象</param>
            <returns>保存了对象序列化数据的一块非托管缓冲区</returns>
        </member>
        <member name="M:Accelbuffer.Unsafe.UnmanagedTypeSerializer.Serialize``1(``0,System.Byte[]@)">
            <summary>
            序列化对象，并将序列化数据写入指定的缓冲区中
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="obj">被序列化的对象</param>
            <param name="buffer">保存了对象序列化数据的缓冲区</param>
        </member>
        <member name="M:Accelbuffer.Unsafe.UnmanagedTypeSerializer.Serialize``1(``0,System.Byte[],System.Int32)">
            <summary>
            序列化对象，并将序列化数据写入指定的缓冲区中
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="obj">被序列化的对象</param>
            <param name="buffer">用于接受序列化数据的缓冲区</param>
            <param name="index">开始读取的索引位置</param>
            <returns>序列化数据的大小</returns>
            <exception cref="T:System.ArgumentException">字节数组容量不足</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.UnmanagedTypeSerializer.Deserialize``1(System.Byte[],System.Int32)">
            <summary>
            反序列化<typeparamref name="T"/>类型对象实例
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="bytes">保存了对象数据的字节数组</param>
            <param name="index">开始读取的索引位置</param>
            <returns>反序列化的对象实例</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="bytes"/>为null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bytes"/>长度不足</exception>
        </member>
        <member name="M:Accelbuffer.Unsafe.UnmanagedTypeSerializer.Deserialize``1(Accelbuffer.Memory.NativeBuffer,System.Int32)">
            <summary>
            反序列化<typeparamref name="T"/>类型对象实例
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="buffer">保存了对象数据的非托管缓冲区</param>
            <param name="index">开始读取的索引位置</param>
            <returns>反序列化的对象实例</returns>
            <exception cref="T:System.ArgumentException"><paramref name="buffer"/>已经被释放</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="buffer"/>长度不足</exception>
        </member>
        <member name="T:Accelbuffer.VInt">
            <summary>
            表示一个动态长度的有符号整数
            </summary>
        </member>
        <member name="T:Accelbuffer.VUInt">
            <summary>
            表示一个动态长度的无符号整数
            </summary>
        </member>
        <member name="T:Accelbuffer.Properties.Resources">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Culture">
            <summary>
              重写当前线程的 CurrentUICulture 属性
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.ASCIIStringByteCountError">
            <summary>
              查找类似 ASCII字符串的字节数量必须是非负数 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.BoolName">
            <summary>
              查找类似 Boolean 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.ByteArrayIsNull">
            <summary>
              查找类似 字节数组不能为空 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.ByteArrayTooShort">
            <summary>
              查找类似 字节数组长度过小 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.ByteName">
            <summary>
              查找类似 UInt8 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.CharName">
            <summary>
              查找类似 Char 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Color32Name">
            <summary>
              查找类似 Color32 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.ColorName">
            <summary>
              查找类似 Color 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.DecimalName">
            <summary>
              查找类似 Float128 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.DeserializeMethodName">
            <summary>
              查找类似 Deserialize 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.DoubleName">
            <summary>
              查找类似 Float64 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS001_InvalidChar">
            <summary>
              查找类似 error: AS001: invalid character: &apos;{0}&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS002_MissingDocEnd">
            <summary>
              查找类似 error: AS002: missing &apos;--&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS003_MissingIdentifier">
            <summary>
              查找类似 error: AS003: missing identifier 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS004_MissingSemicolon">
            <summary>
              查找类似 error: AS004: missing &apos;;&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS005_InvalidIdentifier">
            <summary>
              查找类似 error: AS005: invalid identifier: &apos;{0}&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS006_InvalidPackage">
            <summary>
              查找类似 error: AS006: package declaration should be the first non empty statement of the file 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS007_InvalidToken">
            <summary>
              查找类似 error: AS007: invalid token: &apos;{0}&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS008_MultipleKeyword">
            <summary>
              查找类似 error: AS008: duplicate keyword: &apos;{0}&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS009_MultipleAccessKeyword">
            <summary>
              查找类似 error: AS009: duplicate access modifier 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS010_InvalidFinalKeyword">
            <summary>
              查找类似 error: AS010: only structures marked with the &apos;ref&apos; keyword can be marked as&apos; final &apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS011_MissingIntLiteral">
            <summary>
              查找类似 error: AS011: missing integer value 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS012_MissingOpenBrace">
            <summary>
              查找类似 error: AS012: missing &apos;{{&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS013_InvalidFieldIndex">
            <summary>
              查找类似 error: AS013: field index must be in range (0, 268435456] 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS014_MissingColonOrBar">
            <summary>
              查找类似 error: AS014: missing &apos;:&apos; or &apos;|&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS015_MissingSemicolonOrObsoleteKeyword">
            <summary>
              查找类似 error: AS015: missing &apos;;&apos; or &apos;obsolete&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS016_MissingIdentifierOrAsterisk">
            <summary>
              查找类似 error: AS016: missing identifier or &apos;*&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS017_MissingCloseBrace">
            <summary>
              查找类似 error: AS017: missing &apos;}}&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS018_InvalidPrivateKeyword">
            <summary>
              查找类似 error: AS018: keyword &apos;private&apos; can only be used in nested types 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS019_InvalidProtectedKeyword">
            <summary>
              查找类似 error: AS019: keyword &apos;protected&apos; can only be used in nested types 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS020_MultipleIndex">
            <summary>
              查找类似 error: AS020: duplicate field index &apos;{0}&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Error_AS021_MissingCloseParen">
            <summary>
              查找类似 error: AS021: missing &apos;)&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.FloatName">
            <summary>
              查找类似 Float32 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.GenericName">
            <summary>
              查找类似 Generic 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.HasNextName">
            <summary>
              查找类似 HasNext 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.IntName">
            <summary>
              查找类似 Int32 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.IntPtrName">
            <summary>
              查找类似 IntPtr 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.InvalidCastFormat">
            <summary>
              查找类似 不存在从{0}到{1}的隐式转换 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.InvalidFieldIndex">
            <summary>
              查找类似 字段的索引必须是 (0, 268435456] 范围内的整数 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.InvalidSerializerType">
            <summary>
              查找类似 所有的序列化代理必须要实现ITypeSerializer&lt;T&gt;接口 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.InvalidUTF8Char">
            <summary>
              查找类似 UTF8字符的第一个字节的格式必须满足&apos;0vvvvvvv&apos;或&apos;110vvvvv&apos;或&apos;1110vvvv&apos; 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.LongName">
            <summary>
              查找类似 Int64 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.NotSupportHighRankArray">
            <summary>
              查找类似 不支持多维数组序列化与反序列化 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.NotSupportTypeInjection">
            <summary>
              查找类似 无法为{0}类型注入代理，因为类型没有无参构造方法 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.QuaternionName">
            <summary>
              查找类似 Quaternion 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.ReadName">
            <summary>
              查找类似 Read 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.RuntimeAssemblyName">
            <summary>
              查找类似 RuntimeTypes.dll 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.RuntimeModuleName">
            <summary>
              查找类似 RuntimeTypesModule 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.SavedAssemblyName">
            <summary>
              查找类似 DynamicAssembly.dll 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.SByteName">
            <summary>
              查找类似 Int8 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.SerializeMethodName">
            <summary>
              查找类似 Serialize 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.SerializerTypeIsNull">
            <summary>
              查找类似 序列化代理类型不能为null 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.SerializerTypeSuffix">
            <summary>
              查找类似 Serializer 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.ShortName">
            <summary>
              查找类似 Int16 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.SkipNextName">
            <summary>
              查找类似 SkipNext 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.StreamTooShort">
            <summary>
              查找类似 数据流的长度过小 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.StringName">
            <summary>
              查找类似 String 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.UIntName">
            <summary>
              查找类似 UInt32 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.UIntPtrName">
            <summary>
              查找类似 UIntPtr 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.ULongName">
            <summary>
              查找类似 UInt64 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.UnicodeStringByteCountError">
            <summary>
              查找类似 Unicode字符串的字节数量必须是非负偶数 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.UShortName">
            <summary>
              查找类似 UInt16 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.UTF8StringByteCountError">
            <summary>
              查找类似 UTF8字符串的字节数量必须是非负数 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Vector2IntName">
            <summary>
              查找类似 Vector2Int 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Vector2Name">
            <summary>
              查找类似 Vector2 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Vector3IntName">
            <summary>
              查找类似 Vector3Int 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Vector3Name">
            <summary>
              查找类似 Vector3 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Vector4Name">
            <summary>
              查找类似 Vector4 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Version">
            <summary>
              查找类似 v0.1.6.14 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Version_Unity">
            <summary>
              查找类似 v0.1.6.14 unity 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.VIntName">
            <summary>
              查找类似 VariantInt 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.VUIntName">
            <summary>
              查找类似 VariantUInt 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Warning_AS001_InvalidMemorySize">
            <summary>
              查找类似 warning: AS001: the memory size required for the structure must be greater than 0 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Warning_AS002_UnnecessaryUsing">
            <summary>
              查找类似 warning: AS002: package &apos;{0}&apos; will be referenced automatically, no need to manually reference again 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.Warning_AS003_RequireContinuousIndex">
            <summary>
              查找类似 warning: AS003: the indexes of fields should be as continuous as possible 的本地化字符串。
            </summary>
        </member>
        <member name="P:Accelbuffer.Properties.Resources.WriteValueMethodName">
            <summary>
              查找类似 WriteValue 的本地化字符串。
            </summary>
        </member>
        <member name="T:Accelbuffer.StreamTooShortException">
            <summary>
            数据流的长度过短错误
            </summary>
        </member>
        <member name="M:Accelbuffer.StreamTooShortException.#ctor">
            <summary>
            初始化 StreamTooShortException
            </summary>
        </member>
        <member name="M:Accelbuffer.StreamTooShortException.#ctor(System.String)">
            <summary>
            初始化 StreamTooShortException
            </summary>
            <param name="message">描述错误的消息</param>
        </member>
        <member name="M:Accelbuffer.StreamTooShortException.#ctor(System.String,System.Exception)">
            <summary>
            初始化 StreamTooShortException
            </summary>
            <param name="message">描述错误的消息</param>
            <param name="inner">导致当前异常的异常；如果未指定内部异常，则是一个 null 引用（在 Visual Basic 中为 Nothing）。</param>
        </member>
        <member name="T:Accelbuffer.AccelReader">
            <summary>
            公开对字节数据的读取与转换接口
            </summary>
        </member>
        <member name="M:Accelbuffer.AccelReader.HasNext">
            <summary>
            获取是否还有下一个值
            </summary>
            <returns>如果还有值，返回true，否则，false</returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.HasNext(System.Int32@)">
            <summary>
            获取是否还有下一个值
            </summary>
            <param name="index">下一个值的索引</param>
            <returns>如果还有值，返回true，否则，false</returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.SkipNext">
            <summary>
            跳过下一个值
            </summary>
            <exception cref="T:System.NotSupportedException">下一个值的类型是非法的</exception>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadInt8">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadUInt8">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadInt16">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadUInt16">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadInt32">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadUInt32">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadInt64">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadUInt64">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadVariantInt">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadVariantUInt">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadIntPtr">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadUIntPtr">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadFloat32">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadFloat64">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadFloat128">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadBoolean">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadChar">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Accelbuffer.AccelReader.ReadGeneric``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:Accelbuffer.Encoding">
            <summary>
            表示字符串的编码
            </summary>
        </member>
        <member name="F:Accelbuffer.Encoding.UTF8">
            <summary>
            指示字符串使用UTF8进行编码
            </summary>
        </member>
        <member name="F:Accelbuffer.Encoding.Unicode">
            <summary>
            指示字符串使用Unicode进行编码
            </summary>
        </member>
        <member name="F:Accelbuffer.Encoding.ASCII">
            <summary>
            指示字符串使用ASCII进行编码
            </summary>
        </member>
        <member name="T:Accelbuffer.ITypeSerializer`1">
            <summary>
            实现接口完成指定类型对象的序列化和反序列化
            </summary>
            <typeparam name="T">序列化的对象的类型</typeparam>
        </member>
        <member name="M:Accelbuffer.ITypeSerializer`1.Serialize(`0,Accelbuffer.AccelWriter@)">
            <summary>
            方法用于实现对象的序列化
            </summary>
            <param name="obj">将被序列化的对象</param>
            <param name="writer">数据输出流</param>
        </member>
        <member name="M:Accelbuffer.ITypeSerializer`1.Deserialize(Accelbuffer.AccelReader@)">
            <summary>
            方法用于实现对象的反序列化
            </summary>
            <param name="reader">数据输入流</param>
            <returns>反序列化对象</returns>
        </member>
        <member name="T:Accelbuffer.SerializeByAttribute">
            <summary>
            用于指定类型的序列化和反序列化代理的类型
            </summary>
        </member>
        <member name="P:Accelbuffer.SerializeByAttribute.SerializerType">
            <summary>
            获取序列化代理类型
            </summary>
        </member>
        <member name="M:Accelbuffer.SerializeByAttribute.#ctor(System.Type)">
            <summary>
            初始化 SerializeByAttribute 实例，并指示运行时使用<paramref name="serializerType"/>类型实现序列化与反序列化
            </summary>
            <param name="serializerType">序列化代理类型</param>
        </member>
        <member name="T:Accelbuffer.Serializer">
            <summary>
            公开序列化对象的接口
            </summary>
        </member>
        <member name="M:Accelbuffer.Serializer.InitializeForType``1">
            <summary>
            初始化类型的序列化代理
            </summary>
            <typeparam name="T">需要初始化的类型</typeparam>
        </member>
        <member name="M:Accelbuffer.Serializer.AddCallback``1(Accelbuffer.SerializationCallbackType,Accelbuffer.SerializationCallback{``0})">
            <summary>
            添加一个序列化/反序列化事件的回调
            </summary>
            <typeparam name="T">序列化/反序列化对象的类型</typeparam>
            <param name="type">回调的类型</param>
            <param name="callback">回调委托</param>
        </member>
        <member name="M:Accelbuffer.Serializer.AddCallback``1(Accelbuffer.SerializationCallback{``0},Accelbuffer.SerializationCallback{``0})">
            <summary>
            添加序列化和反序列化事件的回调
            </summary>
            <typeparam name="T">序列化/反序列化对象的类型</typeparam>
            <param name="onBeforeSerialization">在序列化前调用的回调</param>
            <param name="onAfterDeserialization">在反序列化后调用的回调</param>
        </member>
        <member name="M:Accelbuffer.Serializer.RemoveCallback``1(Accelbuffer.SerializationCallbackType,Accelbuffer.SerializationCallback{``0})">
            <summary>
            移除一个序列化/反序列化事件的回调
            </summary>
            <typeparam name="T">序列化/反序列化对象的类型</typeparam>
            <param name="type">回调的类型</param>
            <param name="callback">回调委托</param>
        </member>
        <member name="M:Accelbuffer.Serializer.RemoveCallback``1(Accelbuffer.SerializationCallback{``0},Accelbuffer.SerializationCallback{``0})">
            <summary>
            移除序列化和反序列化事件的回调
            </summary>
            <typeparam name="T">序列化/反序列化对象的类型</typeparam>
            <param name="onBeforeSerialization">在序列化前调用的回调</param>
            <param name="onAfterDeserialization">在反序列化后调用的回调</param>
        </member>
        <member name="M:Accelbuffer.Serializer.Serialize``1(``0,Accelbuffer.Encoding,Accelbuffer.Endian)">
            <summary>
            序列化对象，并返回序列化数据
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="obj">被序列化的对象</param>
            <param name="encoding">序列化使用的字符编码</param>
            <param name="endian">序列化使用的字节序</param>
            <returns>保存了对象序列化数据的一块非托管缓冲区</returns>
        </member>
        <member name="M:Accelbuffer.Serializer.Serialize``1(``0,System.Byte[]@,Accelbuffer.Encoding,Accelbuffer.Endian)">
            <summary>
            序列化对象，并将序列化数据写入缓冲区中
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="obj">被序列化的对象</param>
            <param name="buffer">对象的序列化结果</param>
            <param name="encoding">序列化使用的字符编码</param>
            <param name="endian">序列化使用的字节序</param>
        </member>
        <member name="M:Accelbuffer.Serializer.Serialize``1(``0,System.Byte[],System.Int32,Accelbuffer.Encoding,Accelbuffer.Endian)">
            <summary>
            序列化对象，并将序列化数据写入指定的缓冲区中
            </summary>
            <typeparam name="T">序列化的对象类型</typeparam>
            <param name="obj">被序列化的对象</param>
            <param name="buffer">用于接受序列化数据的缓冲区</param>
            <param name="index"><paramref name="buffer"/>开始写入的索引</param>
            <param name="encoding">序列化使用的字符编码</param>
            <param name="endian">序列化使用的字节序</param>
            <returns>序列化数据的大小</returns>
            <exception cref="T:System.ArgumentException">字节数组容量不足</exception>
        </member>
        <member name="M:Accelbuffer.Serializer.Serialize(System.Object,Accelbuffer.Reflection.AccelTypeInfo,Accelbuffer.Encoding,Accelbuffer.Endian)">
            <summary>
            序列化对象，并将序列化数据写入缓冲区中
            </summary>
            <param name="obj">被序列化的对象</param>
            <param name="type">序列化的对象类型</param>
            <param name="encoding">序列化使用的字符编码</param>
            <param name="endian">序列化使用的字节序</param>
            <returns>对象的序列化结果</returns>
        </member>
        <member name="M:Accelbuffer.Serializer.Deserialize``1(System.Byte[],System.Int32,System.Int32)">
            <summary>
            反序列化<typeparamref name="T"/>类型对象实例
            </summary>
            <typeparam name="T">反序列化的对象类型</typeparam>
            <param name="bytes">保存了对象数据的字节数组</param>
            <param name="index">开始读取的索引位置</param>
            <param name="length">可以读取的字节大小</param>
            <returns>反序列化的对象实例</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="bytes"/>为null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bytes"/>长度不足</exception>
        </member>
        <member name="M:Accelbuffer.Serializer.Deserialize``1(Accelbuffer.Memory.NativeBuffer,System.Int32,System.Int32)">
            <summary>
            反序列化<typeparamref name="T"/>类型对象实例
            </summary>
            <typeparam name="T">反序列化的对象类型</typeparam>
            <param name="buffer">保存了对象数据的非托管缓冲区</param>
            <param name="index">开始读取的索引位置</param>
            <param name="length">可以读取的字节大小</param>
            <returns>反序列化的对象实例</returns>
            <exception cref="T:System.ArgumentException"><paramref name="buffer"/>已经被释放</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="buffer"/>长度不足</exception>
        </member>
        <member name="M:Accelbuffer.Serializer.Deserialize(Accelbuffer.Reflection.AccelTypeInfo,System.Byte[],System.Int32,System.Int32)">
            <summary>
            反序列化<see cref="T:Accelbuffer.Reflection.AccelTypeInfo"/>类型对象实例
            </summary>
            <param name="type">反序列化的对象类型</param>
            <param name="bytes">保存了对象数据的字节数组</param>
            <param name="index">开始读取的索引位置</param>
            <param name="length">可以读取的字节大小</param>
            <returns>反序列化的对象实例</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="bytes"/>为null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bytes"/>长度不足</exception>
        </member>
        <member name="T:Accelbuffer.ObjectType">
            <summary>
            表示一个对象的数据类型（4位）
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed0">
            <summary>
            丢失的类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed8">
            <summary>
            8位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed16">
            <summary>
            16位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed24">
            <summary>
            24位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed32">
            <summary>
            32位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed40">
            <summary>
            40位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed48">
            <summary>
            48位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed56">
            <summary>
            56位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed64">
            <summary>
            64位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed72">
            <summary>
            72位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed80">
            <summary>
            80位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed88">
            <summary>
            88位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed96">
            <summary>
            96位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed104">
            <summary>
            104位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.Fixed128">
            <summary>
            128位固定长度类型
            </summary>
        </member>
        <member name="F:Accelbuffer.ObjectType.LengthPrefixed">
            <summary>
            前缀长度类型（Variant字节长度 + N字节数据）
            </summary>
        </member>
        <member name="T:Accelbuffer.AccelWriter">
            <summary>
            公开对字节数据的写入接口
            </summary>
        </member>
        <member name="P:Accelbuffer.AccelWriter.ByteCount">
            <summary>
            获取当前写入的字节数量
            </summary>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.SByte)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.Byte)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.Int16)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.UInt16)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.UInt32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.Int64)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.UInt64)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,Accelbuffer.VInt)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,Accelbuffer.VUInt)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.UIntPtr)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.Single)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.Double)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.Decimal)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.Char)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:Accelbuffer.AccelWriter.WriteValue``1(System.Int32,``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="index"></param>
            <param name="value"></param>
        </member>
    </members>
</doc>
